import numpy as np
import mne
from scipy.io import loadmat
from scipy.signal import welch
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score
import matplotlib.pyplot as plt
import os

# Chemin du dossier contenant les fichiers
folder_path = '/root/code/will-they-wake-up/will-they-wake-up/physionet.org/static/published-projects/i-care/2.0/training/0286'
# Lister tous les fichiers .mat
mat_files = [f for f in os.listdir(folder_path) if f.endswith('.mat')]
print(f"Fichiers trouvés : {mat_files}")
# Charger le fichier .mat
file_path = '/root/code/will-they-wake-up/will-they-wake-up/physionet.org/static/published-projects/i-care/2.0/training/0286/0286_001_020_ECG.mat'
data = loadmat(file_path)

# Afficher les clés pour exploration
print("Clés disponibles dans le fichier :", data.keys())

# Extraction des signaux EEG - Modifier selon la structure réelle
eeg_signals = data.get('val', None)
if eeg_signals is None:
    raise ValueError("La clé pour les signaux EEG n'est pas trouvée dans le fichier.")

# Dimensions des signaux
n_channels, n_samples = eeg_signals.shape
print(f"Nombre de canaux : {n_channels}, Nombre d'échantillons : {n_samples}")

# Paramètres (si disponibles dans le fichier)
fs = data.get('fs', 256)  # Fréquence d'échantillonnage, par défaut 256 Hz

# Création d'un objet RawArray MNE pour visualisation
channel_names = [f"Ch{i+1}" for i in range(n_channels)]
channel_types = ['eeg'] * n_channels
info = mne.create_info(channel_names, sfreq=fs, ch_types=channel_types)
raw = mne.io.RawArray(eeg_signals, info)

# Visualisation des données
raw.plot(title="Données EEG brutes")

# Filtrage
raw.filter(0.5, 40)  # Filtre passe-bande 0.5-40 Hz

# Extraction des caractéristiques
def extract_features(data, fs):
    f, psd = welch(data, fs=fs, nperseg=fs*2)
    bands = {
        "delta": (f >= 0.5) & (f < 4),
        "theta": (f >= 4) & (f < 8),
        "alpha": (f >= 8) & (f < 13),
        "beta": (f >= 13) & (f < 30),
        "gamma": (f >= 30) & (f < 40),
    }
    features = {band: np.mean(psd[:, idx], axis=1) for band, idx in bands.items()}
    return features

features = extract_features(eeg_signals, fs)
print("Caractéristiques extraites :", features)

# Construction de jeu de données fictif
X = np.array(list(features.values())).T
y = np.random.randint(0, 2, X.shape[0])  # Étiquettes fictives : 0 ou 1

# Division en ensembles d'entraînement et de test
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Modèle de prédiction
model = RandomForestClassifier()
model.fit(X_train, y_train)
y_pred = model.predict(X_test)
accuracy = accuracy_score(y_test, y_pred)
print(f"Précision du modèle : {accuracy:.2f}")

# Préparer les données pour le graphique
bands = list(features.keys())  # ['delta', 'theta', 'alpha', 'beta', 'gamma']
values = np.array(list(features.values()))  # Convertir les valeurs en tableau numpy

# Barres groupées par canal
n_channels = values.shape[1]
channels = range(1, n_channels + 1)  # [1, 2, ..., n_channels]
width = 0.15  # Largeur des barres

# Création du graphique en barres
fig, ax = plt.subplots(figsize=(12, 6))
for i, band in enumerate(bands):
    ax.bar(
        [x + i * width for x in channels],  # Position des barres
        values[i],  # Valeurs pour la bande actuelle
        width=width,
        label=band
    )

# Configurer l'affichage
ax.set_xticks([x + width for x in channels])
ax.set_xticklabels([f"Ch{x}" for x in channels])
ax.set_title("Densité spectrale moyenne par bande EEG et par canal")
ax.set_xlabel("Canaux EEG")
ax.set_ylabel("Densité spectrale moyenne (PSD)")
ax.legend(title="Bandes de fréquence")

# Affichage du graphique
plt.show(block=True)
plt.tight_layout()
plt.show()
